<b>CS 61A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Lecture Notes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Week 5</b>
<div class="p"><!----></div>
Topic: Hierarchical data/Scheme interpreter
<div class="p"><!----></div>
<b>Reading:</b>
Abelson &amp; Sussman, Section 2.2.2-2.2.3, 2.3.1, 2.3.3
<div class="p"><!----></div>
<b>Midterm 1 is this week.</b>

<div class="p"><!----></div>
<font face="symbol"></font
> Example: A Calculator Program

<div class="p"><!----></div>
Later in the course we'll be studying several variants of a Scheme interpreter
written in Scheme.  As a first, small step in that direction, here is an
interactive calculator that accepts arithmetic expressions in Scheme notation,
but without variables, without the ability to define procedures, and with no
data types other than numbers.  Here's how it works:

<div class="p"><!----></div>
<tt>  <pre>STk&#62; (load "&#126;cs61a/lib/calc.scm")
STk&#62; (calc)
calc: (+ 2 3)
5
calc: (+ (* 2 3) (* 4 5))
26
calc: foo
Error: calc: bad expression: foo

</pre></tt>

<div class="p"><!----></div>
The last example shows that there are no variables in this language.

<div class="p"><!----></div>
The entire program consists of three procedures in 30 lines of code.  You
should find it easy to understand.  And yet these three procedures exactly
parallel the core procedures in a real Scheme interpreter:

<div class="p"><!----></div>
<dl><dd>1.  The read-eval-print loop: interact with the user.

<div class="p"><!----></div>
2.  Eval: <tt>(eval expression)</tt> returns the value of the expression.

<div class="p"><!----></div>
3.  Apply: <tt>(apply function argument-values)</tt> calls the function and
returns the value it returns.

<div class="p"><!----></div>
</dd></dl>Here's the read-eval-print loop (or REPL, pronounced "rep-uhl"):

<div class="p"><!----></div>
<tt>  <pre>(define (calc)
  (display "calc: ")
  (flush)
  (print (calc-eval (read)))
  (calc))

</pre></tt>

<div class="p"><!----></div>
The calls to <tt>display</tt> and <tt>flush</tt> print the user prompt.  (<tt>Flush</tt>
is used when you want to print something that doesn't end with a newline
character, but you want it to print right away.  Ordinarily, most programs,
including STk, save up the characters you print until you finish a line, then
send the entire line to the operating system at once.  <tt>Flush</tt> tells STk
not to wait for the end of the line.)

<div class="p"><!----></div>
The most important line is the <tt>(print (calc-eval (read)))</tt>.  <tt>Read</tt>
is a Scheme primitive that reads a datum from the keyboard.  "Datum" here
means a word, a list, or any other single Scheme value.  In our case, the
things we're reading are Scheme expressions, but <tt>read</tt> doesn't know that;
as far as <tt>read</tt> is concerned, <tt>(+&nbsp;2&nbsp;3)</tt> is just a list of three
elements, not a request to add two numbers.

<div class="p"><!----></div>
The fact that a Scheme expression is just a Scheme datum-a list-makes it
very easy to write an interpreter.  This is why Scheme uses the <tt>(+&nbsp;2&nbsp;3)</tt>
notation for function calls rather than, say, <tt>+(2,3)</tt> as in the usual
mathematical notation for functions!  Even a more complicated expression such
as <tt>(+&nbsp;(*&nbsp;2&nbsp;3)&nbsp;(*&nbsp;4&nbsp;5))</tt> is one single Scheme datum, a list, in which some
of the elements are themselves lists.

<div class="p"><!----></div>
What do we want to do with the thing <tt>read</tt> returns?  We want to treat it
as an expression in this Scheme-subset language and <i>evaluate </i> it.
That's the job of <tt>calc-eval</tt>.  (We use the names <tt>calc-eval</tt> and
<tt>calc-apply</tt> in this program because STk has primitive procedures called
<tt>eval</tt> and <tt>apply</tt>, and we don't want to step on those names.  The STk
procedures have jobs exactly analogous to the ones in <tt>calc</tt>, though;
every interpreter for any Lisp-family language has some form of <tt>eval</tt> and
<tt>apply</tt>.)

<div class="p"><!----></div>
Once we get the value from <tt>eval</tt>, what do we want to do with it?  We want
to show it to the user by printing it to the display.  That's the job of <tt>
print</tt>.  So now you understand why it's a "read-eval-print" loop!  Read an
expression, evaluate it, and print its value.

<div class="p"><!----></div>
Finally, the procedure ends with a recursive call to itself, so it loops
forever; this is the "loop" part of the REPL.

<div class="p"><!----></div>
Notice that <tt>read</tt> and <tt>print</tt> are not functional programming; <tt>
read</tt> returns a different value each time it's called, and <tt>print</tt> changes
something in the world instead of just returning a value.  The body of the
REPL has more than one expression; Scheme evaluates the expressions in order,
and returns the value of the last expression.  (In this case, though, it never
returns a value at all, since the last expression is a recursive call and
there's no base case to end the recursion.)  In functional programming, it
doesn't make sense to have more than one expression in a procedure body, since
a function can return only one value.

<div class="p"><!----></div>
(It's also worth noting, in passing, that the REPL is the <tt>only</tt>
non-functional part of this program.  Even though we're doing something
interactive, functional programming techniques are still the best way to do
most of the work of the calculator program.)

<div class="p"><!----></div>
The job of <tt>eval</tt> is to turn expressions into values.  It's very
important to remember that those are two different things.  Some people lose
midterm exam points by thinking that when you type <tt>'foo</tt> into Scheme,
it prints out <tt>'foo</tt>.  Of course it really prints <tt>foo</tt> without the
quotation mark.  <tt>Foo</tt> is a possible Scheme value, but <tt>'foo</tt> really
makes sense only as an expression. (Of course, as we've seen, every
expression is also a possible value; what expression would you type to
Scheme to make it print <tt>'foo</tt>?)  What confuses people is that <i>
some </i> things in Scheme are both expressions and values; a number is a Scheme
expression whose value is the number itself.  But most expressions have a
value different from the expression itself.

<div class="p"><!----></div>
Part of what makes one programming language different from another is what
counts as an expression.  In Scheme, certain kinds of expressions have funny
notation rules, such as the extra parentheses around clauses in a <tt>cond</tt>
expression.  The notation used in a language is called its <i>syntax</i>.
<tt>Eval</tt> is the part of a Lisp interpreter that knows about syntax.
Our simplified calculator language has only two kinds of syntax: numbers,
which are <i>self-evaluating </i> (i.e., the value is the number itself),
and lists, which represent function calls:

<div class="p"><!----></div>
<tt>  <pre>(define (calc-eval exp)
  (cond ((number? exp) exp)
	((list? exp) (calc-apply (car exp) (map calc-eval (cdr exp))))
	(else (error "Calc: bad expression:" exp))))

</pre></tt>

<div class="p"><!----></div>
In real Scheme, there are more kinds of self-evaluating expressions, such as
Booleans (<tt>#t</tt> and <tt>#f</tt>) and <tt>&#223;trings&nbsp;in&nbsp;double&nbsp;quotes"</tt>;
there are variables, which are expressions; and some lists are special forms
instead of procedure calls.  So in a Scheme interpreter, <tt>eval</tt> is a
little more complicated, but not that much more.

<div class="p"><!----></div>
By the way, notice that we're talking about two different programming
languages here.  I've said that the calculator language doesn't have
variables, and yet in <tt>calc-eval</tt> we're using a variable named <tt>exp</tt>.
This isn't a contradiction because <tt>calc-eval</tt> isn't itself a program in
calculator-language; it's a program in STk, which is a complete Scheme
interpreter.  The calculator language and Scheme are different enough so that
you probably won't be confused about this, but I'm belaboring the point
because later on we'll see interpreters for much more complete subsets of
Scheme, and you can easily get confused about whether some expression you're
looking at is part of the interpreter, and therefore an STk expression, or
data given to the interpreter, and therefore a mini-Scheme expression.

<div class="p"><!----></div>
The way <tt>calc-eval</tt> handles function calls is the only part of the
calculator that is <i>not </i> the same as the corresponding feature of real
Scheme.  That's because in calculator language, numbers are the only data
type, and so in particular procedures aren't data.  In a real Scheme procedure
call expression, the first subexpression, the one whose value provides the
procedure itself, has to be evaluated just as much as the argument
subexpressions.  <i>Often </i> the first subexpression is just a variable
name, such as <tt>+</tt> or <tt>cdr</tt>, but the expression could be

<div class="p"><!----></div>
<tt>  <pre>((lambda (x) (+ x 5))  (* 2 3))

</pre></tt>

<div class="p"><!----></div>
in which case the first subexpression is a special form, a <tt>lambda</tt>
expression.  But in calculator language, the first sub-"expression" is
always the name of the function, and there are only four possibilities:
<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, and <tt>/</tt>.  I put "expression" in quotes
because these symbols are <i>not </i> expressions in calculator language.
So the expression in <tt>calc-eval</tt> that handles procedure calls is

<div class="p"><!----></div>
<tt>  <pre>(calc-apply (car exp) (map calc-eval (cdr exp)))

</pre></tt>

<div class="p"><!----></div>
The first argument to <tt>calc-apply</tt> is the <i>name </i> of the function we
want to call.  The rest of the expression <tt>exp</tt> consists of actual
argument subexpressions, which we recursively evaluate by calling <tt>
calc-eval</tt> for each of them.  (Remember that <tt>map</tt> is the list version of
<tt>every</tt>; it calls <tt>calc-eval</tt> repeatedly, once for each element of
<tt>(cdr&nbsp;exp)</tt>.)  When we look at a more-nearly-real Scheme interpreter
in another week, the corresponding part of <tt>eval</tt> will look like this:

<div class="p"><!----></div>
<tt>  <pre>(apply (EVAL (car exp)) (map eval (cdr exp)))

</pre></tt>

<div class="p"><!----></div>
<tt>Eval</tt> is the part of the interpreter that knows about the syntax of
the language.  By contrast, <tt>apply</tt> works entirely in the world of values;
there are no expressions at all in the arguments to <tt>apply</tt>.  Our version
of <tt>apply</tt> has the four permitted operations built in:

<div class="p"><!----></div>
<tt>  <pre>(define (calc-apply fn args)
  (cond ((eq? fn '+) (accumulate + 0 args))
	((eq? fn '-) (cond ((null? args) (error "Calc: no args to -"))
			   ((= (length args) 1) (- (car args)))
			   (else (- (car args) (accumulate + 0 (cdr args))))))
	((eq? fn '*) (accumulate * 1 args))
	((eq? fn '/) (cond ((null? args) (error "Calc: no args to /"))
			   ((= (length args) 1) (/ (car args)))
			   (else (/ (car args) (accumulate * 1 (cdr args))))))
	(else (error "Calc: bad operator:" fn))))

</pre></tt>

<div class="p"><!----></div>
The associative operations can be done with a single call to the higher order
<tt>accumulate</tt> function; the non-associative ones have to deal with the
special case of one argument separately.  I'm not spending a lot of time on
the details because this isn't how real Scheme handles function calls; the
real <tt>apply</tt> takes the actual procedure as its first argument, so it
doesn't have to have special knowledge of the operators built into itself.
Also, the real <tt>apply</tt> handles user-defined procedures as well as the ones
built into the language.

<div class="p"><!----></div>

<div class="p"><!----></div>
<table border="0"><tr><td><br />
</td></tr></table><!--vbox--><table border="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="note-figs/6-1.eps">Figure</a>


</td></tr></table><!--vbox--><font face="symbol"></font
> Trees.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Big idea: representing a hierarchy of information.

<div class="p"><!----></div>
What are trees good for?

<div class="p"><!----></div>

<dl compact="compact">
 <dt>
<font face="symbol"></font
></dt>
<dd>
Hierarchy: world, countries, states, cities.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>Ordering: binary search trees.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>Composition: arithmetic operations at branches, numbers at leaves.
</dd></dl>The name "tree" comes from the branching structure of the pictures, like
real trees in nature except that they're drawn with the root at the top and
the leaves at the bottom.

<div class="p"><!----></div>
A <i>node </i> is a point in the tree.  In these pictures, each node includes
a <i>datum </i> (the value shown at the node, such as <tt>France</tt> or <tt>
26</tt>) but also includes the entire structure under that datum and connected
to it, so the <tt>France</tt> node includes all the French cities, such as <tt>
Paris</tt>.  Therefore, <b>each node is itself a tree</b>-the terms "tree" and
"node" mean the same thing!  The reason we have two names for it is that we
generally use "tree" when we mean the entire structure that our program is
manipulating, and "node" when we mean just one piece of the overall
structure.  Therefore, another synonym for "node" is "subtree."

<div class="p"><!----></div>
The <i>root node </i> (or just the <i>root </i>) of a tree is the node at
the top.  Every tree has one root node.  (A more general structure in which
nodes can be arranged more flexibly is called a <i>graph </i>; you'll study
graphs in 61B and later courses.)

<div class="p"><!----></div>
The <i>children </i> of a node are the nodes directly beneath it.  For
example, the children of the <tt>26</tt> node in the picture are the <tt>15</tt>
node and the <tt>33</tt> node.

<div class="p"><!----></div>
A <i>branch </i> node is a node that has at least one child.  A <i>leaf </i>
node is a node that has no children.  (The root node is also a branch node,
except in the trivial case of a one-node tree.)

<div class="p"><!----></div>
<font face="symbol"></font
> <b>The <tt>Tree<!--hbox-->00</tt> abstract data type</b>

<div class="p"><!----></div>
Lisp has one built-in way to represent sequences, but there is no official
way to represent trees.  Why not?

<div class="p"><!----></div>

<dl compact="compact">
 <dt>
<font face="symbol"></font
></dt>
<dd>
Branch nodes may or may not have data.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>Binary vs.&nbsp;n-way trees.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>Order of siblings may or may not matter.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>Can tree be empty?
</dd></dl>We'll get back to some of these variations later, but first we'll consider a
commonly used version of trees, in which every tree has at least one node,
every node has a datum, and nodes can have any number of children.  Here are
the constructor and selectors:

<div class="p"><!----></div>
<tt>  <pre>(make-tree datum children)
(datum node)
(children node)

</pre></tt>

<div class="p"><!----></div>
The selector <tt>children</tt> should return a <i>list of trees</i>, the children
of the node.  These children are themselves trees.  There is a name for a list
of trees: a <i>forest</i>.  It's very important to remember that Tree and
Forest are two different data types!  A forest is just a sequence, although
its elements are required to be trees, and so we can manipulate forests using
the standard procedures for sequences (<tt>cons</tt>, <tt>car</tt>, <tt>cdr</tt>,
etc.); a tree is <i>not </i> a sequence, and should be manipulated only with
the tree constructor and selectors.

<div class="p"><!----></div>
A leaf node is one with no children, so its <tt>children</tt> list is empty:

<div class="p"><!----></div>
<tt>  <pre>(define (leaf? node)
  (null? (children node)) )

</pre></tt>

<div class="p"><!----></div>
This definition of <tt>leaf?</tt>&nbsp;should work no matter how we represent the ADT.

<div class="p"><!----></div>
The straightforward implementation is

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/tree1.scm
(define make-tree cons)
(define datum car)
(define children cdr)

</pre></tt>

<div class="p"><!----></div>
<font face="symbol"></font
> <b>Mapping over trees</b>

<div class="p"><!----></div>
One thing we might want to do with a tree is create another tree, with the
same shape as the original, but with each datum replaced by some function of
the original.  This is the tree equivalent of <tt>map</tt> for lists.

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/tree1.scm
(define (treemap fn tree)
  (make-tree (fn (datum tree))
             (map (lambda (t) (treemap fn t))
                  (children tree) )))

</pre></tt>

<div class="p"><!----></div>
This is a remarkably simple and elegant procedure, especially considering the
versatility of the data structures it can handle (trees of many different
sizes and shapes).  It's one of the more beautiful things you'll see in the
course, so spend some time appreciating it.

<div class="p"><!----></div>
Every tree node consists of a datum and some children.  In the new tree, the
datum corresponding to this node should be the result of applying <tt>fn</tt> to
the datum of this node in the original tree.  What about the children of the
new node?  There should be the same number of children as there are in the
original node, and each new child should be the result of calling <tt>
treemap</tt> on an original child.  Since a forest is just a list, we can use
<tt>map</tt> (not <tt>treemap</tt>!)&nbsp;to generate the new children.

<div class="p"><!----></div>
<font face="symbol"></font
> <b>Mutual recursion</b>

<div class="p"><!----></div>
Pay attention to the strange sort of recursion in this procedure.  <tt>
Treemap</tt> does not actually call itself!  <tt>Treemap</tt> calls <tt>map</tt>, giving
it a function that in turn calls <tt>treemap</tt>.  The result is that each call
to <tt>treemap</tt> may give rise to any number of recursive calls, via <tt>
map</tt>:&nbsp;one call for every child of this node.

<div class="p"><!----></div>
This pattern (procedure <tt>A</tt> invokes procedure <tt>B</tt>, which invokes procedure
<tt>A</tt>) is called <i>mutual recursion</i>.  We can rewrite <tt>treemap</tt>
without using <tt>map</tt>, to make the mutual recursion more visible:

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/tree11.scm
(define (treemap fn tree)
  (make-tree (fn (datum tree))
             (forest-map fn (children tree))))

<div class="p"><!----></div>
(define (forest-map fn forest)
  (if (null? forest)
      '()
      (cons (treemap fn (car forest))
            (forest-map fn (cdr forest)))))

</pre></tt>

<div class="p"><!----></div>
<tt>Forest-map</tt> is a helper function that takes a forest, not a tree, as
argument.  <tt>Treemap</tt> calls <tt>forest-map</tt>, which calls <tt>treemap</tt>.

<div class="p"><!----></div>

<div class="p"><!----></div>
Mutual recursion is what makes it possible to explore the two-dimensional
tree data structure fully.  In particular, note that reaching the base case
in <tt>forest-map</tt> does not mean that the entire tree has been visited!
It means merely that one group of sibling nodes has been visited (a
"horizontal" base case), or that a node has no children (a "vertical" base
case).  The entire tree has been seen when every child of the root node has
been completed.

<div class="p"><!----></div>
Note that we use <tt>cons</tt>, <tt>car</tt>, and <tt>cdr</tt> when manipulating a
forest, but we use <tt>make-tree</tt>, <tt>datum</tt>, and <tt>children</tt> when
manipulating a tree.  Some students make the mistake of thinking that data
abstraction means "always say <tt>datum</tt> instead of <tt>car</tt>"!  But
that defeats the purpose of using different selectors and constructors for
different data types.

<div class="p"><!----></div>
<font face="symbol"></font
> <b>Deep lists</b>

<div class="p"><!----></div>
Trees are our first two-dimensional data structure.  But there's a sense in
which any list that has lists as elements is also two-dimensional, and can be
viewed as a kind of tree.  We'll use the name <i>deep lists </i> for lists
that contain lists.  For example, the list

<div class="p"><!----></div>
<tt>  <pre>[[john lennon] [paul mccartney] [george harrison] [ringo starr]]

</pre></tt>

<div class="p"><!----></div>
is probably best understood as a sequence of sentences, but instead we can draw
a picture of it as a sort of tree:

<div class="p"><!----></div>

<div class="p"><!----></div>
Don't be confused; this is <i>not </i> an example of the Tree abstract
data type we've just developed.  In this picture, for example, only the "leaf
nodes" contain data, namely words.  We didn't make this list with <tt>
make-tree</tt>, and it wouldn't make sense to examine it with <tt>datum</tt> or
<tt>children</tt>.

<div class="p"><!----></div>
But we can still use the <i>ideas </i> of tree manipulation if we'd like to
do something for every word in the list.  Compare the following procedure with
the first version of <tt>treemap</tt> above:

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/tree22.scm
(define (deep-map fn lol)
  (if (list? lol)
      (map (lambda (element) (deep-map fn element))
	   lol)
      (fn lol)))

</pre></tt>

<div class="p"><!----></div>
The formal parameter <tt>lol</tt> stands for "list of lists."  This procedure
includes the two main tasks of <tt>treemap</tt>: applying the function <tt>fn</tt>
to one datum, and using <tt>map</tt> to make a recursive call for each child.

<div class="p"><!----></div>
But <tt>treemap</tt> applies to the Tree abstract data type, in which every node
has both a datum and children, so <tt>treemap</tt> carries out both tasks for
each node.  In a deep list, by contrast, the "branch nodes" have children
but no datum, whereas the "leaf nodes" have a datum but no children.  That's
why <tt>deep-map</tt> chooses only one of the two tasks, using <tt>if</tt> to
distinguish branches from leaves.

<div class="p"><!----></div>
Note:  SICP does not define a Tree abstract data type; they use the term
"tree" to describe what I'm calling a deep list.  So they use the name
<tt>tree-map</tt> in Exercise 2.31, page 113, which asks you to write what I've
called <tt>deep-map</tt>.  (Since I've done it here, you should do the exercise
without using <tt>map</tt>.)  SICP does define an abstract data type for
<i>binary </i> trees, in which each node can have a <tt>left-branch</tt> and/or a
<tt>right-branch</tt>, rather than having any number of children.

<div class="p"><!----></div>

<div class="p"><!----></div>
<font face="symbol"></font
> <b>Car/cdr recursion</b>

<div class="p"><!----></div>
Consider the deep list <tt>((a b) (c d))</tt>.  Ordinarily we would draw its box
and pointer diagram with a horizontal spine at the top and the sublists
beneath the spine:

<div class="p"><!----></div>

<div class="p"><!----></div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="note-figs/6-3.eps">Figure</a>


<div class="p"><!----></div>

<div class="p"><!----></div>
But imagine that we grab the first pair of this structure and "shake" it so
that the pairs fall down as far as they can.  We'd end up with this diagram:

<div class="p"><!----></div>

<div class="p"><!----></div>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="note-figs/6-4.eps">Figure</a>


<div class="p"><!----></div>

<div class="p"><!----></div>
Note that these two diagrams represent the same list!  They have the same
pairs, with the same links from one pair to another.  It's just the position
of the pairs on the page that's different.  But in this new picture, the
structure looks a lot like a binary tree, in which the branch nodes are pairs
and the leaf nodes are atoms (non-pairs).  The "left branch" of each pair
is its <tt>car</tt>, and the "right branch" is its <tt>cdr</tt>.  With this
metaphor, we can rewrite <tt>deep-map</tt> to look more like a binary tree
program:

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/tree3.scm
(define (deep-map fn xmas)
  (cond ((null? xmas) '())
        ((pair? xmas)
         (cons (deep-map fn (car xmas))
               (deep-map fn (cdr xmas))))
        (else (fn xmas))))

</pre></tt>

<div class="p"><!----></div>
(The formal parameter <tt>xmas</tt> reflects the fact that the picture looks
kind of like a Christmas tree.)

<div class="p"><!----></div>
This procedure strongly violates data abstraction!  Ordinarily when dealing
with lists, we write programs that treat the car and the cdr differently,
reflecting the fact that the car of a pair is a list element, whereas the cdr
is a sublist.  But here we treat the car and the cdr identically.  One
advantage of this approach is that it works even for improper lists:

<div class="p"><!----></div>
<tt>  <pre>&#62; (deep-map square '((3 . 4) (5 6))
((9 . 16) (25 36))

</pre></tt>

<div class="p"><!----></div>
The two ways of thinking of a deep list as a tree correspond to the two
abstract tree types:

<div class="p"><!----></div>
<dl><dd><table border="0"><tr><td>
<table>
<tr><td align="right"><b></td><td align="center">&nbsp;&nbsp;&nbsp;<b>N children</td><td align="center">&nbsp;&nbsp;&nbsp;<b>2 children</td></tr>
<tr><td colspan="3" align="left">
<div class="p"><!----></div>
 </td></tr>
<tr><td align="right"><b>Abstract Data Type</td><td align="center">&nbsp;&nbsp;&nbsp;Tree</td><td align="center">&nbsp;&nbsp;&nbsp;binary tree</td></tr>
<tr><td align="right"><b>List</td><td align="center">&nbsp;&nbsp;&nbsp;deep list</td><td align="center">&nbsp;&nbsp;&nbsp;car/cdr</td></tr></b></b></b></b></b></table>

</td></tr></table><!--vbox--></dd></dl>
<div class="p"><!----></div>
<font face="symbol"></font
> <b>Tree recursion</b>

<div class="p"><!----></div>
Compare the car/cdr version of <tt>deep-map</tt> with ordinary <tt>map</tt>:

<div class="p"><!----></div>
<tt>  <pre>(define (map fn seq)
  (if (null? seq)
      '()
      (cons (fn (car seq))
	    (map fn (cdr seq)))))

</pre></tt>

<div class="p"><!----></div>
Each non-base-case invocation of <tt>map</tt> gives rise to one recursive call,
to handle the cdr of the sequence.  The car, an element of the list, is not
handled recursively.

<div class="p"><!----></div>
By contrast, in <tt>deep-map</tt> there are <i>two </i> recursive calls, one for
the car and one for the cdr.  This is what makes the difference between a
sequential, one-dimensional process and the two-dimensional process used for
deep lists and for the Tree abstraction.

<div class="p"><!----></div>
A procedure in which each invocation makes more than one recursive call is
given the name <i>tree recursion </i> because of the relationship between
this pattern and tree structures.  It's tree recursion only if each call
(other than a base case) gives rise to two or more recursive calls; it's
not good enough to have two recursive calls of which only one is chosen each
time, as in the following non-tree-recursive procedure:

<div class="p"><!----></div>
<tt>  <pre>(define (filter pred seq)
  (cond ((null? seq) '())
	((pred (car seq)) (cons (car seq) (filter pred (cdr seq))))
	(else (filter pred (cdr seq)))))

</pre></tt>

<div class="p"><!----></div>
There are two recursive calls to <tt>filter</tt>, but only one of them is
actually carried out each time, so this is a sequential recursion, not a
tree recursion.

<div class="p"><!----></div>
A program can be tree recursive even if there is no actual tree-like data
structure used, as in the Fibonacci number function:

<div class="p"><!----></div>
<tt>  <pre>(define (fib n)
  (if (&lt; n 2)
      1
      (+ (fib (- n 1)) (fib (- n 2)))))

</pre></tt>

<div class="p"><!----></div>
This procedure just handles numbers, not trees, but each non-base-case call
adds the results of two recursive calls, so it's a tree recursive program.

<div class="p"><!----></div>
<font face="symbol"></font
> <b>Tree traversal</b>

<div class="p"><!----></div>
Many problems involve visiting each node of a tree to look for or otherwise
process some information there.  Maybe we're looking for a particular node,
maybe we're adding up all the values at all the nodes, etc.  There is one
obvious order in which to traverse a sequence (left to right), but many ways in
which we can traverse a tree.

<div class="p"><!----></div>
In the following examples, we "visit" each node by printing the datum at
that node.  If you apply these procedures to actual trees, you can see the
order in which the nodes are visited.

<div class="p"><!----></div>
<b>Depth-first traversal:</b>  Look at a given node's children before its siblings.

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/search.scm
(define (depth-first-search tree)
  (print (datum tree))
  (for-each depth-first-search (children tree)))

</pre></tt>

<div class="p"><!----></div>
This is the easiest way, because the program's structure follows the data
structure; each child is traversed in its entirety (that is, including
grandchildren, etc.)&nbsp;before looking at the next child.

<div class="p"><!----></div>
<b>Breadth-first traversal:</b>  Look at the siblings before the children.

<div class="p"><!----></div>
What we want to do is take horizontal slices of the tree.  First we look at
the root node, then we look at the children of the root, then the
grandchildren, and so on.  The program is a little more complicated because
the order in which we want to visit nodes isn't the order in which they're
connected together.

<div class="p"><!----></div>
To solve this, we use an extra data structure, called a <i>queue</i>, which
is just an ordered list of tasks to be carried out.  Each "task" is a node
to visit, and a node is a tree, so a list of nodes is just a forest.  The
iterative helper procedure takes the first task in the queue (the car),
visits that node, and adds its children at the end of the queue (using <tt>
append</tt>).

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/search.scm
(define (breadth-first-search tree)
  (bfs-iter (list tree)))

<div class="p"><!----></div>
(define (bfs-iter queue)
  (if (null? queue)
      'done
      (let ((task (car queue)))
        (print (datum task))
        (bfs-iter (append (cdr queue) (children task))))))

</pre></tt>

<div class="p"><!----></div>
Why would we use this more complicated technique?  For example, in some
situations the same value might appear as a datum more than once in the tree,
and we want to find the <i>shortest </i> path from the root node to a node
containing that datum.  To do that, we have to look at nodes near the root
before looking at nodes far away from the root.

<div class="p"><!----></div>
Another example is a game-strategy program that <i>generates </i> a tree of
moves.  The root node is the initial board position; each child is the result
of a legal move I can make; each child of a child is the result of a legal
move for my opponent, and so on.  For a complicated game, such as chess, the
move tree is much too large to generate in its entirety.  So we use a
breadth-first technique to generate the move tree up to a certain depth (say,
ten moves), then we look for desirable board positions at that depth.  (If we
used a depth-first program, we'd follow one path all the way to the end of the
game before starting to consider a different possible first move.)

<div class="p"><!----></div>
For binary trees, within the general category of depth-first traversals, there
are three possible variants:

<div class="p"><!----></div>
Preorder:  Look at a node before its children.

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/print.scm
(define (pre-order tree)
  (cond ((null? tree) '())
        (else (print (entry tree))
              (pre-order (left-branch tree))
              (pre-order (right-branch tree)) )))

</pre></tt>

<div class="p"><!----></div>
Inorder:  Look at the left child, then the node, then
the right child.

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/print.scm
(define (in-order tree)
  (cond ((null? tree) '())
        (else (in-order (left-branch tree))
              (print (entry tree))
              (in-order (right-branch tree)) )))

</pre></tt>

<div class="p"><!----></div>

<div class="p"><!----></div>
Postorder:  Look at the children before the node.

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/print.scm
(define (post-order tree)
  (cond ((null? tree) '())
        (else (post-order (left-branch tree))
              (post-order (right-branch tree))
              (print (entry tree)) )))

</pre></tt>

<div class="p"><!----></div>
For a tree of arithmetic operations, preorder traversal looks like Lisp; inorder
traversal looks like
conventional arithmetic notation; and postorder traversal is the HP calculator
"reverse Polish notation."

<div class="p"><!----></div>
<font face="symbol"></font
> <b>Path finding</b>

<div class="p"><!----></div>
As an example of a somewhat more complicated tree program, suppose we want
to look up a place (e.g., a city) in the world tree, and find the path from
the root node to that place:

<div class="p"><!----></div>
<tt>  <pre>&#62; (find-place 'berkeley world-tree)
(world (united states) california berkeley)

</pre></tt>

<div class="p"><!----></div>
If a place isn't found, <tt>find-place</tt> will return the empty list.

<div class="p"><!----></div>
To find a place within some tree, first we see if the place is the datum of
the root node.  If so, the answer is a one-element list containing just the place.
Otherwise, we look at each child of the root, and see if we can find the place
within that child.  If so, the path within the complete tree is the path
within the child, but with the root datum added at the front of the path.
For example, the path to Berkeley within the USA subtree is

<div class="p"><!----></div>
<tt>  <pre>((united states) california berkeley)

</pre></tt>

<div class="p"><!----></div>
so we put <tt>world</tt> in front of that.

<div class="p"><!----></div>
Broadly speaking, this program has the same mutually recursive tree/forest
structure as the other examples we've seen, but one important difference is
that once we've found the place we're looking for, there's no need to visit
other subtrees.  Therefore, we don't want to use <tt>map</tt> or anything
equivalent to handle the children of a node; we want to check the first
child, see if we've found a path, and only if we haven't found it should we
go on to the second child (if any).  This is the reason for the <tt>let</tt> in
<tt>find-forest</tt>.

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/world.scm
(define (find-place place tree)
  (if (eq? place (datum tree))
      (cons (datum tree) '())
      (let ((try (find-forest place (children tree))))
	(if (not (null? try))
	    (cons (datum tree) try)
	    '()))))

<div class="p"><!----></div>
(define (find-forest place forest)
  (if (null? forest)
      '()
      (let ((try (find-place place (car forest))))
        (if (not (null? try))
            try
            (find-forest place (cdr forest))))))

</pre></tt>

<div class="p"><!----></div>
(Note: In 61B we come back to trees in more depth, including the study of
<i>balanced </i> trees, i.e., using special techniques to make sure a search
tree has about as much stuff on the left as on the right.)

<div class="p"><!----></div>

<div class="p"><!----></div>
<font face="symbol"></font
> The <tt>Scheme-1</tt> interpreter

<div class="p"><!----></div>
<b>[This topic may be in week 5 or in week 6 depending on the
holiday schedule.]</b>

<div class="p"><!----></div>
We're going to investigate a Scheme interpreter written in Scheme.  SICP
has a rather large and detailed Scheme interpreter in Chapter 4, which
we'll get to near the end of the semester.  But students often find
that program intimidating, so we're going to work up to it with a
series of three smaller versions that leave out some details and some
of the features of real Scheme.  This week we'll use the <tt>Scheme-1</tt>
interpreter.

<div class="p"><!----></div>
We weren't ready for this investigation until we had the idea of lists
that contain sublists, because that's what a Scheme program is - a list.
That's the point of all those parentheses; the Scheme language can look
at a Scheme program as data, rather than as something different from data.

<div class="p"><!----></div>
Here's how we use the interpreter:

<div class="p"><!----></div>
<tt>  <pre>STk&#62; (load "&#126;cs61a/lib/scheme1.scm")
STk&#62; (scheme-1)
Scheme-1: (+ 2 3)
5
Scheme-1: ((lambda (x) (* x 3)) 4)
12

</pre></tt>

<div class="p"><!----></div>
To leave <tt>Scheme-1</tt> and return to the STk prompt, just enter an
illegal expression, such as <tt>()</tt>.

<div class="p"><!----></div>
Why bother?  What good is an interpreter for Scheme that we can't use unless
we already have another interpreter for Scheme?

<div class="p"><!----></div>

<dl compact="compact">
 <dt>
<font face="symbol"></font
></dt>
<dd>
It helps you understand evaluation models.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>It lets us experiment with modifications to Scheme (new features).
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>Even real Scheme interpreters are largely written in Scheme.
</dd>
 <dt>
<font face="symbol"></font
></dt>
<dd>It illustrates a big idea:&nbsp;<i>universality</i>.
</dd></dl>
This week's interpreter implements the <i>substitution </i> model of
evaluation that we learned in Chapter 1 of SICP.  In Chapter 3, we'll get to
a more complicated but more realistic evaluation model, called the
<i>environment </i> model.

<div class="p"><!----></div>
Universality means we can write <i>one program </i> that's equivalent to all
other programs.  We'll talk more about this when we see SICP's full
Scheme interpreter in Chapter 4.  This week's interpreter, although
universal in principle, doesn't make the point clearly because it's
quite difficult to write serious programs in it, mainly because it
lacks <tt>define</tt>.

<div class="p"><!----></div>
Our Scheme interpreter leaves out many of the important components of a real
one.  It gets away with this by taking advantage of the capabilities of the
underlying Scheme.  Specifically, we don't deal with storage allocation,
tail recursion elimination, or implementing any of the Scheme primitives.
All we <i>do </i> deal with is the evaluation of expressions.  That turns
out to be quite a lot in itself, and pretty interesting.

<div class="p"><!----></div>

<div class="p"><!----></div>
Here is a one-screenful version of a Scheme interpreter, using the
substitution model, with most of the details left out:

<div class="p"><!----></div>
<tt>  <pre>;;;;;                        In file cs61a/lectures/2.2/tiny.scm
(define (scheme)
  (display &#187; ")
  (print (eval (read)))
  (scheme) )

<div class="p"><!----></div>
(define (eval exp)
  (cond ((self-evaluating? exp) exp)
        ((symbol? exp) (look-up-global-value exp))
        ((special-form? exp) (do-special-form exp))
        (else (apply (eval (car exp))
                     (map eval (cdr exp)) ))))

<div class="p"><!----></div>
(define (apply proc args)
  (if (primitive? proc)
      (do-magic proc args)
      (eval (substitute (body proc) (formals proc) args))))

</pre></tt>

<div class="p"><!----></div>
Although the versions we can actually run are bigger, this really does capture
the essential structure of every Lisp interpreter, namely, a mutual
recursion between <tt>eval</tt> (evaluate an expression) and <tt>apply</tt> (apply a
function to arguments).  To evaluate a procedure call means to evaluate
the subexpressions recursively, then apply the <tt>car</tt> (a function) to the
<tt>cdr</tt> (the arguments).  To apply a function to arguments means to
evaluate the body of the function with the argument values in place of
the formal parameters.

<div class="p"><!----></div>
The <tt>substitute</tt> procedure is essentially the <tt>substitute2</tt> that
you wrote in last week's homework, except that it has to be a little more
complicated to avoid substituting for quoted symbols and for the formal
parameters of a <tt>lambda</tt> inside the body.

<div class="p"><!----></div>
What's left out?  Primitives, special forms, and a lot of details.

<div class="p"><!----></div>
The <tt>Scheme-1</tt> interpreter has only three special forms: <tt>quote</tt>,
<tt>if</tt>, and <tt>lambda</tt>.  In particular, it doesn't have <tt>define</tt>,
so there are no global variables, and
we can't give procedures global names.  If we need a name for a
procedure, we have to use it as an argument to another procedure.
In particular, if we want to write <i>recursive </i> procedures we
have to use a trick that was an extra-for-experts in week 2:

<div class="p"><!----></div>
<tt>  <pre>Scheme-1: ((lambda (n)
	     ((lambda (f) (f f n))   ; the "Y combinator"
	      (lambda (fact n)
		(if (= n 0)
		    1
		    (* n (fact fact (- n 1))) )) ))
	   5)
120

</pre></tt>

<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
